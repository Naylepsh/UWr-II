
Wybrane elementy praktyki projektowania oprogramowaniaZestaw 4Javascript - dziedziczenie prototypowe, biblioteka standardowa2019-11-05Liczba punktów do zdobycia:10/40Zestaw ważny do: 2019-11-191. (1p) Węzeł drzewa binarnego (Tree) to obiekt który przechowuje referencje do swojegolewego i prawego syna oraz wartość (np. liczba lub napis). Pokazać jak zdefiniować funkcjękonstruktorową tworzącą taki węzeł (argumentami funkcji powinny być właśnie: lewe iprawe poddrzewo oraz wartość węzła). Pokazać przykład użycia tej funkcji do utworzeniainstancji drzewa o głębokości 3 (nie musi być to drzewo pełne).2. (1p) Do prototypu funkcji drzewa binarnego z poprzedniego przykładu dodać iterator(zaimplementowany jako generator przy użyciuyield), który pozwoli napisaćvar root = new Tree( ..... );// enumeracja wartości z węzłówfor ( var e of root ){console.log( e );}3. (1p) Na dowolnym przykładzie zademonstrować jak można uzyskać efekt ”składowychprywatnych” znany z wielu języków obiektowych.Formalnie: zdefiniować funkcję konstruktorowąFoo, do jej prototypu dodać metodę pu-blicznąBar, którą można zawołać na nowo tworzonych instancjach obiektów, ale w cielefunkcjiBarzawołać funkcjęQuxktóra jest funkcją prywatną dla instancji tworzonych przezFoo(czyli że funkcjiQuxnie da się zawołać ani wprost na instancjachFooani w żadeninny sposób niż tylko z wewnątrz metody publicznejBar).4. (1p) Zademonstrować w praktyce tworzenie własnych modułów oraz ich włączanie dokodu za pomocąrequire. Czy możliwa jest sytuacja w której dwa moduły tworzą cykl(odwołują się do siebie nawzajem)? Jeśli nie - wytłumaczyć dlaczego, jeśli tak - pokazaćprzykład implementacji.5. (1p) Napisać program, który wypisze na ekranie zapytanie o imię użytkownika, odczyta zkonsoli wprowadzony tekst, a następnie wypiszeWitaj ***gdzie puste miejsce zostaniewypełnione wprowadzonym przez użytkownika napisem. Użyć dowolnej techniki do speł-nienia tego wymagania, ale nie korzystać z zewnętrznych modułów znpma wyłącznie zobiektów z biblioteki standardowej (wszystkie te techniki sprowadzają się do jakiejś formydojścia do strumieniaprocess.stdin).6. (1p) Napisać program używający modułu (fs), który przeczyta w całości plik tekstowy anastępnie wypisze jego zawartość na konsoli.1
7. (2p) Pokazać w jaki sposób odczytywać duże pliki linia po linii za pomocą modułureadline. Działanie zademonstrować na przykładowym kodzie analizującym duży pliklogów hipotetycznego serwera WWW, w którym każda linia ma postać08:55:36 192.168.0.1 GET /TheApplication/WebResource.axd 200gdzie poszczególne wartości oznaczają czas, adres klienta, rodzaj żądania HTTP, nazwęzasobu oraz status odpowiedzi.W przykładowej aplikacji wydobyć listę adresów IP trzech klientów, którzy skierowali doserwera aplikacji największą liczbę żądań.Wynikiem działania programu powinien być przykładowy raport postaci:12.34.56.78 14323.45.67.89 113123.245.167.289 898. (2p) Wybrać jeden z modułów i funkcję asynchroniczną do odczytu danych (fs::readFile)i pokazać klasyczny interfejs programowania asynchronicznego, w którym asynchronicznywynik wywołania funkcji jest dostarczany jako argument do funkcji zwrotnej (callback).Następnie pokazać jak taki klasyczny interfejs można zmienić naPromisena trzy sposoby:•za pomocą ”ręcznie” napisanej funkcji przyjmującej te same argumenty cofs::readFileale zwracającejPromise•za pomocąutil.promisifyz biblioteki standardowej•za pomocąfs.promisesz biblioteki standardowejNa zademonstrowanym przykładzie pokazać dwa sposoby obsługi funkcji zwracającejPromise•”po staremu” - wywołanie z kontynuacją (Promise::then)•”po nowemu” - wywołanie przezasync/awaitWiktor Zychla2
